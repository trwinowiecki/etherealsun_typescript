-- -- SEQUENCE: public.favorite_products_id_seq
-- -- DROP SEQUENCE IF EXISTS public.favorite_products_id_seq;
-- CREATE SEQUENCE IF NOT EXISTS public.favorite_products_id_seq INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1;
-- ALTER SEQUENCE public.favorite_products_id_seq OWNER TO postgres;
-- GRANT ALL ON SEQUENCE public.favorite_products_id_seq TO anon;
-- GRANT ALL ON SEQUENCE public.favorite_products_id_seq TO authenticated;
-- GRANT ALL ON SEQUENCE public.favorite_products_id_seq TO postgres;
-- GRANT ALL ON SEQUENCE public.favorite_products_id_seq TO service_role;
-- -- SEQUENCE: public.featured_products_id_seq
-- -- DROP SEQUENCE IF EXISTS public.featured_products_id_seq;
-- CREATE SEQUENCE IF NOT EXISTS public.featured_products_id_seq INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1;
-- ALTER SEQUENCE public.featured_products_id_seq OWNER TO postgres;
-- GRANT ALL ON SEQUENCE public.featured_products_id_seq TO anon;
-- GRANT ALL ON SEQUENCE public.featured_products_id_seq TO authenticated;
-- GRANT ALL ON SEQUENCE public.featured_products_id_seq TO postgres;
-- GRANT ALL ON SEQUENCE public.featured_products_id_seq TO service_role;
-- -- Table: public.favorite_products
-- -- DROP TABLE IF EXISTS public.favorite_products;
-- CREATE TABLE IF NOT EXISTS public.favorite_products (
--   id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
--     INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1
--   ),
--   user_id uuid NOT NULL,
--   program_id text COLLATE pg_catalog."default" NOT NULL
-- ) TABLESPACE pg_default;
-- ALTER TABLE
--   IF EXISTS public.favorite_products OWNER to postgres;
-- ALTER TABLE
--   IF EXISTS public.favorite_products ENABLE ROW LEVEL SECURITY;
-- GRANT ALL ON TABLE public.favorite_products TO anon;
-- GRANT ALL ON TABLE public.favorite_products TO authenticated;
-- GRANT ALL ON TABLE public.favorite_products TO postgres;
-- GRANT ALL ON TABLE public.favorite_products TO service_role;
-- COMMENT ON TABLE public.favorite_products IS 'User''s favorited products';
-- -- POLICY: Enable all for users based on user_id
-- -- DROP POLICY IF EXISTS "Enable all for users based on user_id" ON public.favorite_products;
-- CREATE POLICY "Enable all for users based on user_id" ON public.favorite_products AS PERMISSIVE FOR ALL TO public USING ((auth.uid() = user_id));
-- -- Table: public.featured_products
-- -- DROP TABLE IF EXISTS public.featured_products;
-- CREATE TABLE IF NOT EXISTS public.featured_products (
--   id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY (
--     INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1
--   ),
--   title text COLLATE pg_catalog."default",
--   product_id text COLLATE pg_catalog."default" NOT NULL,
--   start_date timestamp with time zone,
--   end_date timestamp with time zone,
--   created_at timestamp with time zone DEFAULT 'now()'
-- ) TABLESPACE pg_default;
-- ALTER TABLE
--   IF EXISTS public.featured_products OWNER to postgres;
-- ALTER TABLE
--   IF EXISTS public.featured_products ENABLE ROW LEVEL SECURITY;
-- GRANT ALL ON TABLE public.featured_products TO anon;
-- GRANT ALL ON TABLE public.featured_products TO authenticated;
-- GRANT ALL ON TABLE public.featured_products TO postgres;
-- GRANT ALL ON TABLE public.featured_products TO service_role;
-- COMMENT ON TABLE public.featured_products IS 'Featured products to be shown on the home page';
-- -- POLICY: Enable read access for all users
-- -- DROP POLICY IF EXISTS "Enable read access for all users" ON public.featured_products;
-- CREATE POLICY "Enable read access for all users" ON public.featured_products AS PERMISSIVE FOR
-- SELECT
--   TO public USING (true);
-- -- Table: public.profiles
-- -- DROP TABLE IF EXISTS public.profiles;
-- CREATE TABLE IF NOT EXISTS public.profiles (
--   id uuid NOT NULL,
--   first_name text COLLATE pg_catalog."default",
--   last_name text COLLATE pg_catalog."default",
--   square_id text COLLATE pg_catalog."default",
--   updated_at timestamp with time zone,
--   CONSTRAINT profiles_pkey PRIMARY KEY (id),
--   CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE CASCADE
-- ) TABLESPACE pg_default;
-- ALTER TABLE
--   IF EXISTS public.profiles OWNER to postgres;
-- ALTER TABLE
--   IF EXISTS public.profiles ENABLE ROW LEVEL SECURITY;
-- GRANT ALL ON TABLE public.profiles TO anon;
-- GRANT ALL ON TABLE public.profiles TO authenticated;
-- GRANT ALL ON TABLE public.profiles TO postgres;
-- GRANT ALL ON TABLE public.profiles TO service_role;
-- -- POLICY: Profiles are visible only by user.
-- -- DROP POLICY IF EXISTS "Profiles are visible only by user." ON public.profiles;
-- CREATE POLICY "Profiles are visible only by user." ON public.profiles AS PERMISSIVE FOR
-- SELECT
--   TO public USING ((auth.uid() = id));
-- -- POLICY: Users can insert their own profile.
-- -- DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
-- CREATE POLICY "Users can insert their own profile." ON public.profiles AS PERMISSIVE FOR
-- INSERT
--   TO public WITH CHECK ((auth.uid() = id));
-- -- POLICY: Users can update own profile.
-- -- DROP POLICY IF EXISTS "Users can update own profile." ON public.profiles;
-- CREATE POLICY "Users can update own profile." ON public.profiles AS PERMISSIVE FOR
-- UPDATE
--   TO public USING ((auth.uid() = id));
-- -- FUNCTION: public.handle_new_user()
-- -- DROP FUNCTION IF EXISTS public.handle_new_user();
-- CREATE
-- OR REPLACE FUNCTION public.handle_new_user() RETURNS trigger LANGUAGE 'plpgsql' COST 100 VOLATILE NOT LEAKPROOF SECURITY DEFINER
-- SET
--   search_path = public AS $ BODY $ begin
-- insert into
--   public.profiles (id)
-- values
--   (new.id);
-- return new;
-- end;
-- $ BODY $;
-- ALTER FUNCTION public.handle_new_user() OWNER TO postgres;
-- GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;
-- GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;
-- GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;
-- GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;
-- GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;
-- -- Trigger: on_auth_user_created
-- -- DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
-- CREATE TRIGGER on_auth_user_created
-- AFTER
-- INSERT
--   ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();